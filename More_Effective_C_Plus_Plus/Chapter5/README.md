定制的类型转换符：
类的支持隐式的类型转换
具体如下：
class ClassName
{
	public:
		....
		operator Data_type()
		{
			return ...;
		}
}

但是隐式转化携带的问题是当重载<<之后，使用std::cout不会调用隐士类型转换


另外重载的==操作符会和隐式转化的构造函数产生意想不到的结果，可使用explicit将构造函数的隐式转化取消
或着在类中再构建一个proxy class，主要的原因是编译器不支持想构造函数一样支持两次隐式转换，具体看代码；