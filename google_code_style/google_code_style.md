Cpplint.py可以检查代码风格

##C++特性##
#参数引用#
尽量使用const

#右值引用#
右值引用是一种只能绑定到临时对象的引用的一种, 其语法与传统的引用语法相似. 例如, void f(string&& s); 声明了一个其参数是一个字符串的右值引用的函数.
右值可实现指移动不拷贝的优点，例如， v1 是一个 vector<string>, 则 auto v2(std::move(v1)) 将很可能不再进行大量的数据复制而只是简单地进行指针操作, 在某些情况下这将带来大幅度的性能提升.
移动构造函数与移动赋值操作时使用右值引用, 不要使用 std::forward 功能函数. 你可能会使用 std::move 来表示将值从一个对象移动而不是复制到另一个对象.

#函数重载#
一般构造函数会有很多重载，构造函数重载使用同一个名字。
其它，打算重载一个函数, 可以试试改在函数名里加上参数信息。例如，用 AppendString() 和 AppendInt() 等， 而不是一口气重载多个 Append().

#缺省参数#
不建议使用缺省参数，尽量使用函数重载，主要原因是缺省参数会影响函数指针
一下几种情况可以使用：
其一，位于 .cc 文件里的静态函数或匿名空间函数，毕竟都只能在局部文件里调用该函数了。
其二，可以在构造函数里用缺省参数，毕竟不可能取得它们的地址。
其三，可以用来模拟变长数组。如下 ：
string StrCat(const AlphaNum &a,
              const AlphaNum &b = gEmptyAlphaNum,
              const AlphaNum &c = gEmptyAlphaNum,
              const AlphaNum &d = gEmptyAlphaNum);

#变长数组和 alloca()#
不允许使用，原因：
变长数组和 alloca() 不是标准 C++ 的组成部分. 更重要的是, 它们根据数据大小动态分配堆栈内存, 会引起难以发现的内存越界 bugs: “在我的机器上运行的好好的, 发布后却莫名其妙的挂掉了”.
建议使用分配器，std::vector或者std::unique<T>

#友元#
允许合理的使用友元，友元扩大了类的封装边界（但没有打破），相比如将类的成员声明成public，使用友元将是更好的选择

#RTTI和异常#
不建议异常使用：异常的处理需要严格的处理，google现有的项目大多数没有异常处理
RTTI容易被乱用：
基于类型的判断树是一个很强的暗示, 它说明你的代码已经偏离正轨了. 不要像下面这样:
if (typeid(*data) == typeid(D1)) {
  ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
...
一旦在类层级中加入新的子类, 像这样的代码往往会崩溃. 而且, 一旦某个子类的属性改变了, 你很难找到并修改所有受影响的代码块.

#类型转换#
不要使用C的强制转换类型，建议使用C++的数据类型转黄
用 static_cast 替代 C 风格的值转换, 或某个类指针需要明确的向上转换为父类指针时.
用 const_cast 去掉 const 限定符.
用 reinterpret_cast 指针类型和整型或其它指针之间进行不安全的相互转换. 仅在你对所做一切了然于心时使用.

#流#
多使用流。
只有在如下情况使用printf：日志接口需要. 使用 printf 之类的代替.

#前置自增和自减#
尽量使用前置，后自加还需要考虑拷贝带来的效率损失

